import { PublicIdentity } from "../crypto/identity.js";
import { TimeChunkedEventQueue } from "./time-chunked-event-queue.js";
import { channelRecv, channelSend } from "./message.js";

/**
 * @template S, E
 * @typedef {import("./message.js").Message<S, E>} Message<S, E>
 */
/**
 * @template E
 * @typedef {import("./simulation.js").PeerMessage<E>} PeerMessage<E>
 */

/**
 * @template S, E
 * @typedef {Object} ServerCallbacks
 * @property {function(void): S} getState
 */

/** @template S, E */
export class Server {
  /**
   * @memberof Server
   * @param {ServerCallbacks<S, E>} callbacks
   * @param {number} [now]
   */
  constructor(callbacks, now = performance.now()) {
    this.tickPeriodMs = 50;
    this.msgTime = 0;
    /**
     * @type {TimeChunkedEventQueue<{
     *   msg: PeerMessage<E>;
     *   clientId: string;
     *   msgTime: number;
     * }>}
     */
    this.eventQueue = new TimeChunkedEventQueue({
      simTime: 0,
      tickPeriodMs: this.tickPeriodMs,
      timeChunkMs: 10,
      now,
    });
    /** @type {{ [key: string]: RTCDataChannel }} */
    this.clients = {};
    this.callbacks = callbacks;
    this.clientId = "host";
    this.tickTimer = null;

    this.eventQueue.pushMsg({
      msg: { type: "peerJoined" },
      clientId: this.clientId,
      msgTime: this.msgTime,
    });
  }

  start() {
    this.tickTimer = setInterval(() => {
      this.onTick();
    }, this.tickPeriodMs);
  }

  /**
   * @template S, E
   * @param {ServerCallbacks<S, E>} callbacks
   */
  static init(callbacks, now = performance.now()) {
    const server = new Server(callbacks, now);
    server.start();
    return server;
  }

  onTick() {
    this.msgTime = this.msgTime + this.tickPeriodMs;
    this.eventQueue.processTick(this.msgTime);
    this.broadcast({ type: "tick", msgTime: this.msgTime });
  }

  getEvents(time = performance.now()) {
    return this.eventQueue.getEvents(time);
  }

  /**
   * This is use for sending both client events and server events
   *
   * @param {E} peerEvent
   */
  sendEvent(peerEvent) {
    this.sendClientEvent(this.clientId, peerEvent);
  }

  /**
   * @param {string} clientId
   * @param {E} peerEvent
   */
  sendClientEvent(clientId, peerEvent) {
    /** @type {PeerMessage<E>} */
    const msg = {
      type: "peerEvent",
      peerEvent,
    };
    this.broadcast({
      type: "peerMessage",
      msg,
      clientId: clientId,
      msgTime: this.msgTime,
    });
  }
  /** @param {Message<S, E>} msg */
  broadcast(msg) {
    const data = JSON.stringify(msg);
    for (let clientId of Object.keys(this.clients)) {
      this.clients[clientId].send(data);
    }
    if (msg.type === "peerMessage") {
      this.eventQueue.pushMsg({
        msg: msg.msg,
        clientId: msg.clientId,
        msgTime: msg.msgTime,
      });
    }
  }
  /** @param {RTCDataChannel} channel */
  async onConnect(channel) {
    const { identity } = await channelRecv(channel, "identity");

    const publicIdentity = await PublicIdentity.fromJSON(identity);

    const { challenge, verify } = publicIdentity.challenge();

    channelSend(channel, { challenge }, "challenge");

    const { signature } = await channelRecv(channel, "signature");

    if (!(await verify(signature))) {
      throw new Error("Signature verification failed");
    }

    // The cool thing about this id is that it's generated by the client
    // but we can also verify that it's unique by checking the signature
    const clientId = await publicIdentity.toName();

    if (this.clients[clientId]) {
      this.onDisconnect(clientId);
    }
    this.clients[clientId] = channel;
    channel.onclose = () => {
      console.log("client disconnected", clientId);
      this.onDisconnect(clientId);
    };
    channel.onerror = (e) => {
      console.error(e);
      this.onDisconnect(clientId);
    };
    channel.onmessage = (e) => {
      // TODO handle parse failure here (and other places)
      const peerEvent = JSON.parse(e.data);
      this.sendClientEvent(clientId, peerEvent);
    };

    let state = this.callbacks.getState();
    channelSend(
      channel,
      {
        clientId,
        ...this.eventQueue.parameters(),
        state,
      },
      "connected"
    );

    this.broadcast({
      type: "peerMessage",
      msg: {
        type: "peerJoined",
      },
      clientId,
      msgTime: this.msgTime,
    });
  }

  /** @param {string} clientId */
  onDisconnect(clientId) {
    this.clients[clientId].close();
    delete this.clients[clientId];

    this.broadcast({
      type: "peerMessage",
      msg: {
        type: "peerLeft",
      },
      clientId,
      msgTime: this.msgTime,
    });
  }
}
